# generated by datamodel-codegen:
#   filename:  run-results_v1.json
#   timestamp: 2022-03-01T06:21:36+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import Extra

from dbt_artifacts_parser.parsers.base import BaseParserModel


class BaseArtifactMetadata(BaseParserModel):

    class Config:
        extra = Extra.forbid

    dbt_schema_version: str
    dbt_version: Optional[str] = '0.19.0'
    generated_at: Optional[datetime] = '2021-02-10T04:42:33.678063Z'
    invocation_id: Optional[Optional[str]] = None
    env: Optional[Dict[str, str]] = {}


class Status(Enum):
    success = 'success'
    error = 'error'
    skipped = 'skipped'


class Status1(Enum):
    pass_ = 'pass'
    error = 'error'
    fail = 'fail'
    warn = 'warn'


class Status2(Enum):
    pass_ = 'pass'
    warn = 'warn'
    error = 'error'
    runtime_error = 'runtime error'


class TimingInfo(BaseParserModel):

    class Config:
        extra = Extra.forbid

    name: str
    started_at: Optional[Optional[datetime]] = None
    completed_at: Optional[Optional[datetime]] = None


class RunResultOutput(BaseParserModel):

    class Config:
        extra = Extra.forbid

    status: Union[Status, Status1, Status2]
    timing: List[TimingInfo]
    thread_id: str
    execution_time: float
    message: Optional[Optional[Union[str, int]]] = None
    adapter_response: Dict[str, Any]
    unique_id: str


class RunResultsV1(BaseParserModel):

    class Config:
        extra = Extra.forbid

    metadata: BaseArtifactMetadata
    results: List[RunResultOutput]
    elapsed_time: float
    args: Optional[Dict[str, Any]] = {}



metadata_obj = BaseArtifactMetadata(
    dbt_schema_version='1.0',
    dbt_version='0.20.0',
    generated_at=datetime.now(),
    invocation_id='123456789',
    env={'key1': 'value1', 'key2': 'value2'}
)

for attr, value in metadata_obj.__dict__.items():
    print(f"{attr}: {value}")


# Print the object
print(metadata_obj.dbt_schema_version)

timing_info_obj = TimingInfo(
    name='Task 1',
    started_at=datetime.now(),
    completed_at=datetime.now()
)

# Print the object
print(timing_info_obj)

status_obj = Status('success')  # Create Status object
status1_obj = Status1('error')  # Create Status1 object
status2_obj = Status2('warn')  # Create Status2 object
timing_info_objs = [ timing_info_obj] 

# Update the adapter_response dictionary to replace "=" by ":"
adapter_response = {'key': 'value'}

# Replace "=" by ":" in the adapter_response dictionary
adapter_response_with_colons = {k.replace('=', ':'): v for k, v in adapter_response.items()}

# Create the RunResultOutput object with the updated adapter_response dictionary
run_result_output_objs = [
    RunResultOutput(
        status=status_obj,
        timing=timing_info_objs,
        thread_id='123456',
        execution_time=10.5,
        adapter_response=adapter_response_with_colons,
        unique_id='987654321'
    )  # Create objects for RunResultOutput if needed
]



# run_result_output_objs = [
#     RunResultOutput(
#     status=status_obj,
#     timing=timing_info_objs,
#     thread_id='123456',
#     execution_time=10.5,
#     adapter_response={'key': 'value'},
#     unique_id='987654321'
# )  # Create objects for RunResultOutput if needed
# ]

run_results_v1_obj = RunResultsV1(
    metadata=metadata_obj,
    results=run_result_output_objs,
    elapsed_time=10.5,
    args={'arg1': 'value1', 'arg2': 'value2'}
)

parsed_result = RunResultsV1(**run_results_v1_obj.dict())

# Print the parsed_result
print("PARSED_RESULT",parsed_result)


parsed_result_str = str(parsed_result)

# Define the file path where you want to save the text file
file_path = 'parsed_result.txt'

# Write the string representation to the text file
with open(file_path, 'w') as file:
    file.write(parsed_result_str)

print(f"Parsed result saved to '{file_path}'")

